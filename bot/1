package bot

import (
	"github.com/graarh/golang-socketio"
	"github.com/graarh/golang-socketio/transport"
	"net/http"
	"strconv"
	"fmt"
	"time"
)

type Message map[string]interface{}
type Handler func(msg Message)

type HandlerSet map[string]Handler

type Bot struct {
	cli *gosocketio.Client
	headers http.Header
	hs HandlerSet
	id, dialog_id int
}

func NewBot() (*Bot) {
	bot := new(Bot)
	bot.headers = make(http.Header)
	handlerSet := make(HandlerSet)
	// Set wanted headers	
	bot.headers.Add("Accept-Encoding", "gzip, deflate")
	bot.headers.Add("Accept-Language", "en-US,en;q=0.9")
	bot.headers.Add("Cache-Control", "no-cache")
	bot.headers.Add("Pragma", "no-cache")
	bot.headers.Add("Origin", "http://nekto.me")
	bot.headers.Add("Host", "im.nekto.me")
	bot.headers.Add("User-Agent", "Mozilla/5.0 (X11; Darwin x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Mojave Chromium/73.0.3683.86 Chrome/73.0.3683.86 Safari/537.36")
	// Init default headers to headerSet
	handlerSet["auth.successToken"] = func (msg Message) {
		fmt.Println("success token, great job!")
		mg := msg["data"].(map[string]interface{})
		bot.id = mg["id"].(int)
	}
	handlerSet["error.code"] = func (msg Message) {
		fmt.Println("error, look at this:", msg)
	}
	handlerSet["captcha.verify"] = func (msg Message) {
		fmt.Println("captcha", msg)
	}
	handlerSet["search.success"] = func (msg Message) {
		fmt.Println("searching for stranger...")
	}
	handlerSet["dialog.opened"] = func (msg Message) {
		fmt.Println("dialog opened")
	}
	handlerSet["dialog.typing"] = func (msg Message) {
		fmt.Println("stranger typing")
	}
	handlerSet["messages.reads"] = func (msg Message) {
		fmt.Println("stranger reads")
	}
	handlerSet["messages.new"] = func (msg Message) {
		mg := msg["data"].(map[string]interface{})
		fmt.Println(mg["message"])
	}
	handlerSet["dialog.closed"] = func (msg Message) {
		fmt.Println("dialog closed")
	}
	handlerSet["unexpected"] = func (msg Message) {
		fmt.Println("bot doesn't know about this messge type, you should add it to bot.hs", msg)
	}
	bot.hs = handlerSet
	return bot
}

func (bot *Bot) SetCookie(cookie string) {
	bot.headers.Set("Cookie", cookie)
}

// Connect to the server and pass auth, token might be just empty string
func (bot *Bot) Connect(token string) error {
	tptr := &transport.WebsocketTransport{
		PingInterval: 20 * time.Second,
		PingTimeout: 10 * time.Second,
		ReceiveTimeout: transport.WsDefaultReceiveTimeout,
		SendTimeout: transport.WsDefaultSendTimeout,
		BufferSize: transport.WsDefaultBufferSize,
		RequestHeader: bot.headers,
	}
	c, err := gosocketio.Dial(gosocketio.GetUrl("im.nekto.me", 79, false), tptr)
	if err != nil {
		return err
	}

	err = c.On("notice", func(h *gosocketio.Channel, args Message) {
		bot.hs[args["notice"].(string)](args)
	})
	if err != nil {
		return err
	}

	err = c.On(gosocketio.OnDisconnection, func(h *gosocketio.Channel) {
		fmt.Println("Disconnected from the server")
	})
	if err != nil {
		return err
	}

	err = c.On(gosocketio.OnConnection, func(h *gosocketio.Channel) {
		fmt.Println("Connected to the server")
		if token == "" {
			c.Emit("action", map[string]interface{}{"action":"auth.getToken","deviceType": 2})
		} else {
			c.Emit("action", map[string]interface{}{"action":"auth.sendToken","token":token})
		}
	})
	if err != nil {
		return err
	}
	bot.cli = c
	return nil
}

func (bot *Bot) SendMessage(msg string) {
		t := time.Now()
		bot.cli.Emit("action", map[string]interface{}{"action":"anon.message","dialogId":bot.dialog_id,
		"message":msg,"randomId":strconv.Itoa(bot.id)+"_"+strconv.FormatInt(t.Unix(), 10)})
}

func (bot *Bot) LeaveDialog() {
	bot.cli.Emit("action", map[string]interface{}{"action":"anon.leaveDialog", "dialogId": bot.dialog_id})
}

func (bot *Bot) StartSearch() {
	bot.cli.Emit("action", map[string]interface{}{"action":"search.run","myAge":[]int{18, 21},"mySex":"M","wishAge":*new([]int),"wishSex":"F"})
}

func (bot *Bot) Track() {
	bot.cli.Emit("action", map[string]interface{}{"action":"online.track","on":true})
}

func (bot *Bot) UnTrack() {
	bot.cli.Emit("action", map[string]interface{}{"action":"online.track","on":false})
}

func (bot *Bot) Close() {
	bot.cli.Close()
}

